---
title: "ARIMAX analysis"
format:
  html:
    code-overflow: wrap
editor: visual
---

# ARIMAX Specification and Reproducibility Protocol

```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
```

To evaluate the robustness and explanatory consistency of external regressors, a systematic model iteration was conducted across twelve ARIMAX specifications (`arimax_model_1` – `arimax_model_12`).\
Each iteration removed one variable or seasonal dummy to examine its incremental contribution to model fit and predictive accuracy.\
This process follows the principle of nested model comparison, where simplified models are contrasted against the full specification to test whether variable exclusion significantly deteriorates performance.

In particular, the inclusion of monthly dummy variables (February–December) serves as a set of seasonal fixed effects, controlling for recurring cyclical fluctuations in theft cases that are not captured by the main explanatory variables.\
This design enables the ARIMAX framework to separate structural drivers (e.g., copper price, intervention policy) from periodic seasonality, thereby improving model interpretability.

The model selection criterion prioritised both statistical significance and forecasting consistency, assessed through coefficient stability, AIC/BIC scores, and diagnostic tests on residual independence and stationarity.\
The twelfth specification (`arimax_model_12`), where all non-significant seasonal effects were removed, was ultimately identified as the most parsimonious and interpretable model for the given dataset.

```{r}
# Construct external varibale matrix
Xreg_matrix_1 <- model.matrix(~ Total_theft.lag + Scrap_Imports_CN.lag + Copper_price.lag + Unwork_NSW.lag + intervention.lag + t_since.lag + Feb + Mar + APr + May + Jun + Jul + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_1 <- auto.arima(train_data$cases, xreg = Xreg_matrix_1, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_1)

# Coefficient test
coeftest(arimax_model_1)
```

```{r}
# Construct external varibale matrix (t_since.lag)
Xreg_matrix_2 <- model.matrix(~ Total_theft.lag + Scrap_Imports_CN.lag + Copper_price.lag + Unwork_NSW.lag + intervention.lag + Feb + Mar + APr + May + Jun + Jul + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_2 <- auto.arima(train_data$cases, xreg = Xreg_matrix_2, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_2)

# Coefficient test
coeftest(arimax_model_2)
```

```{r}
# Construct external varibale matrix (Remove Unwork_NSW)
Xreg_matrix_3 <- model.matrix(~ Total_theft.lag + Scrap_Imports_CN.lag + Copper_price.lag + intervention.lag + Feb + Mar + APr + May + Jun + Jul + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_3 <- auto.arima(train_data$cases, xreg = Xreg_matrix_3, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_3)

# Coefficient test
coeftest(arimax_model_3)
```

```{r}
# Construct external varibale matrix (remove Scrap_Imports_CN.lag)
Xreg_matrix_4 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Feb + Mar + APr + May + Jun + Jul + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_4 <- auto.arima(train_data$cases, xreg = Xreg_matrix_4, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_4)

# Coefficient test
coeftest(arimax_model_4)
```

```{r}
# Construct external varibale matrix (Feb)
Xreg_matrix_5 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + APr + May + Jun + Jul + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_5 <- auto.arima(train_data$cases, xreg = Xreg_matrix_5, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_5)

# Coefficient test
coeftest(arimax_model_5)
```

```{r}
# Construct external varibale matrix (Jul)
Xreg_matrix_6 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + APr + May + Jun + Aug + Sep + Oct + Nov + Dec, data = train_data)

# Train the SARIMAX model
arimax_model_6 <- auto.arima(train_data$cases, xreg = Xreg_matrix_6, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_6)

# Coefficient test
coeftest(arimax_model_6)
```

```{r}
# Construct external varibale matrix (remove Dec)
Xreg_matrix_7 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + APr + May + Jun + Aug + Sep + Oct + Nov, data = train_data)

# Train the SARIMAX model
arimax_model_7 <- auto.arima(train_data$cases, xreg = Xreg_matrix_7, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_7)

# Coefficient test
coeftest(arimax_model_7)
```

```{r}
# Construct external varibale matrix (remove Aug)
Xreg_matrix_8 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + APr + May + Jun + Sep + Oct + Nov, data = train_data)

# Train the SARIMAX model
arimax_model_8 <- auto.arima(train_data$cases, xreg = Xreg_matrix_8, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_8)

# Coefficient test
coeftest(arimax_model_8)
```

```{r}
# Construct external varibale matrix (remove Oct)
Xreg_matrix_9 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + APr + May + Jun + Sep + Nov, data = train_data)

# Train the SARIMAX model
arimax_model_9 <- auto.arima(train_data$cases, xreg = Xreg_matrix_9, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_9)

# Coefficient test
coeftest(arimax_model_9)
```

```{r}
# Construct external varibale matrix (remove APr)
Xreg_matrix_10 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + Mar + May + Jun + Sep + Nov, data = train_data)

# Train the SARIMAX model
arimax_model_10 <- auto.arima(train_data$cases, xreg = Xreg_matrix_10, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_10)

# Coefficient test
coeftest(arimax_model_10)
```

```{r}
# Construct external varibale matrix (remove Mar)
Xreg_matrix_11 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + May + Jun + Sep + Nov, data = train_data)

# Train the SARIMAX model
arimax_model_11 <- auto.arima(train_data$cases, xreg = Xreg_matrix_11, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_11)

# Coefficient test
coeftest(arimax_model_11)
```

```{r}
# Construct external varibale matrix (remove Nov)
Xreg_matrix_12 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + May + Jun + Sep, data = train_data)

# Train the SARIMAX model
arimax_model_12 <- auto.arima(train_data$cases, xreg = Xreg_matrix_12, max.p = 5, max.d = 2, max.q = 5, 
                             seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
# Model summary
summary(arimax_model_12)

# Coefficient test
coeftest(arimax_model_12)
```

## Residual Diagnostics

Diagnostic testing was conducted to verify the adequacy of the final ARIMAX model.\

The Ljung–Box test assessed serial independence of residuals, while the Shapiro–Wilk and ARCH LM tests examined normality and heteroscedasticity, respectively.\

Additionally, ADF and KPSS tests were applied to verify the stationarity of residuals—an essential requirement for a valid ARIMA process.\

Together, these diagnostics ensure that the model errors behave as white noise, validating the model’s statistical integrity and forecasting credibility.

```{r}
# Calculating the residual of the final ARIMAX model
residuals_arimax <- residuals(arimax_model_12)

# Conduct Ljung–Box test to examine residual independence  
Box.test(residuals_arimax, lag = 30, type = "Ljung-Box")

# Perform Shapiro–Wilk test to assess normality of residuals  
shapiro_test_result <- shapiro.test(residuals_arimax)
print(shapiro_test_result)

# Use ARCH LM test to detect heteroscedasticity in residuals  
ArchTest(residuals_arimax, lags = 10)

library(tseries)
# Extract residuals from the SARIMAX model  
residuals_arimax <- residuals(arimax_model_12)

# Perform Augmented Dickey–Fuller (ADF) test to evaluate residual stationarity  
adf.test(residuals_arimax)

# Perform KPSS test to evaluate residual stationarity
# null hypothesis: residuals are stationary
kpss_test_result <- kpss.test(residuals_arimax, null = "Level")  

print(kpss_test_result)
```

## Forecasting and Performance Evaluation

Using the finalized ARIMAX model, out-of-sample forecasts were generated for the test dataset.\

Predicted values were compared against actual theft counts using visual step plots and quantitative accuracy measures: ME, RMSE, MAE, MPE, MAPE, MASE, and R².\

This comprehensive performance evaluation framework quantifies not only average forecast bias but also proportional accuracy and scale-invariant consistency.\

The visual overlay of actual and predicted series provides intuitive validation of temporal dynamics captured by the model.

```{r}
library(ggplot2)
library(lubridate)
library(dplyr)

windowsFonts(
  Times = windowsFont("Times New Roman")
)

forecast_xreg_12 <- model.matrix(~ Total_theft.lag + Copper_price.lag + intervention.lag + May + Jun + Sep, data = test_data)
forecast_result_12 <- forecast(arimax_model_12, xreg = forecast_xreg_12)

# Add columns for predicted and actual values
test_data$predicted_cases <- forecast_result_12$mean
test_data$actual_cases <- test_data$cases

# Plotting (Comparison between predicted and actual values)
ggplot(test_data, aes(x = date)) +
  geom_step(aes(y = actual_cases, color = "Actual Cases"), size = 1.2) +
  geom_step(aes(y = predicted_cases, color = "Predicted Cases"), size = 1.2) +
  scale_color_manual(
    values = c("Actual Cases" = "black",
               "Predicted Cases" = "#1f77b4")
  ) +
  scale_x_date(
    date_breaks = "3 months",
    labels = function(x) paste0(format(x, "%Y"), "-Q", lubridate::quarter(x))
  ) +
  scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 20)
  ) +
  labs(
    title = "Comparison of Predicted vs. Actual Cases by Quarter",
    x = "Quarter",
    y = "Number of Theft Cases",
    color = "Legend"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "Times"),
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )


library(dplyr)

# Compute error terms and associated metrics
comparison_data <- test_data %>%
  mutate(
    Error = actual_cases - predicted_cases,
    Abs_Error = abs(Error),
    Squared_Error = Error^2,
    Pct_Error = ifelse(actual_cases == 0, NA, (Error / actual_cases) * 100),
    Abs_Pct_Error = abs(Pct_Error)
  )

# Basic error metrics
ME    <- mean(comparison_data$Error, na.rm = TRUE)
RMSE  <- sqrt(mean(comparison_data$Squared_Error, na.rm = TRUE))
MAE   <- mean(comparison_data$Abs_Error, na.rm = TRUE)
MPE   <- mean(comparison_data$Pct_Error, na.rm = TRUE)
MAPE  <- mean(comparison_data$Abs_Pct_Error, na.rm = TRUE)

# Construct a naive benchmark (for MASE calculation)
comparison_data <- comparison_data %>%
  mutate(
    Naive = lag(actual_cases, 1),
    Naive_Error = actual_cases - Naive,
    Abs_Naive_Error = abs(Naive_Error)
  )
Naive_MAE <- mean(comparison_data$Abs_Naive_Error, na.rm = TRUE)
MASE <- MAE / Naive_MAE

# Compute R² (Coefficient of Determination)
SSE <- sum((comparison_data$actual_cases - comparison_data$predicted_cases)^2, na.rm = TRUE)
SST <- sum((comparison_data$actual_cases - mean(comparison_data$actual_cases, na.rm = TRUE))^2, na.rm = TRUE)
R_squared <- 1 - (SSE / SST)

# Print R² result
cat("R-squared (Coefficient of Determination):", round(R_squared, 4), "\n")

# Output all error metrics
cat("ARIMAX Forecast Error Metrics (Original Scale, Test Set):\n")
cat("---------------------------------------------------------\n")
cat("Mean Error (ME):",    round(ME, 4), "\n")
cat("Root Mean Squared Error (RMSE):", round(RMSE, 4), "\n")
cat("Mean Absolute Error (MAE):",      round(MAE, 4), "\n")
cat("Mean Percentage Error (MPE):",    round(MPE, 4), "%\n")
cat("Mean Absolute Percentage Error (MAPE):", round(MAPE, 4), "%\n")
cat("Mean Absolute Scaled Error (MASE):", round(MASE, 4), "\n")
cat("R-squared (Coefficient of Determination):", round(R_squared, 4), "\n")
```

To complement the numerical residual diagnostics, the Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF) plots were generated for the residual series of the final ARIMAX model. The ACF plot illustrates the degree of correlation between residuals across increasing lags, while the PACF plot isolates the direct correlation at each lag after controlling for intermediate terms.

```{r}
library(forecast)  # For ggAcf and ggPacf functions
library(ggplot2)

windowsFonts(
  Times = windowsFont("Times New Roman")
)

# Plot the Autocorrelation Function (ACF) of residuals
acf_arimax_plot <- ggAcf(residuals_arimax, lag.max = 30) +
  labs(
    title = "ACF of ARIMAX Residuals",
    x = "Lag (Months)",
    y = "Autocorrelation"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    text = element_text(family = "Times"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Plot the Partial Autocorrelation Function (PACF) of residuals
pacf_arimax_plot <- ggPacf(residuals_arimax, lag.max = 30) +
  labs(
    title = "PACF of ARIMAX Residuals",
    x = "Lag (Months)",
    y = "Partial Autocorrelation"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    text = element_text(family = "Times"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Display plots
print(acf_arimax_plot)
print(pacf_arimax_plot)
```

To further ensure the robustness of parameter estimation, multicollinearity among regressors was assessed using Variance Inflation Factor (VIF) analysis.\

All VIF values below 5 indicate that the explanatory variables are sufficiently independent, minimizing potential collinearity-induced distortion.

```{r}

windowsFonts(
  Times = windowsFont("Times New Roman")
)

# Step 1: Fit a linear regression model for computing VIF values
vif_model <- lm(cases ~ Total_theft.lag + Copper_price.lag + intervention.lag + May + Jun + Sep, data = train_data)

# Step 2: Extract VIF values
vif_values <- vif(vif_model)
print("Variance Inflation Factor (VIF) values:")
print(vif_values)

# Step 3: Format into a sorted data frame for visualization
vif_df <- data.frame(
  Variable = names(vif_values),
  VIF = vif_values
) %>%
  arrange(VIF) %>%
  mutate(Variable = factor(Variable, levels = Variable))  # Maintain variable order for plotting

# Step 4: Construct horizontal bar plot using ggplot2
vif_plot <- ggplot(vif_df, aes(x = VIF, y = Variable)) +
  geom_bar(stat = "identity", fill = "#1F77B4", width = 0.3) +
  geom_vline(xintercept = 5, linetype = "dashed", color = "red", linewidth = 0.8) +  # Threshold line
  labs(
    title = "Variance Inflation Factor (VIF) for Predictors",
    x = "VIF Value",
    y = "Predictor Variables"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    text = element_text(family = "Times"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text = element_text(color = "black", size = 10),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Step 5: Print the plot
print(vif_plot)
```

A final robustness test was also performed using standardized data, where continuous predictors were z-score normalized to eliminate scale differences and confirm coefficient stability across units.

```{r}
# Standardization function
zscore <- function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)

# Standardize the dependent variable and all exogenous variables
data_std <- data.frame(
  cases = zscore(train_data$cases),
  Copper_price.lag = zscore(train_data$Copper_price.lag),
  Total_theft.lag = zscore(train_data$Total_theft.lag),
  intervention = train_data$intervention.lag,
  May = train_data$May, # Dummy variables do not need to be standardized
  Jun = train_data$Jun,
  Sep = train_data$Sep
)

arimax_std <- arima(
  data_std$cases,
  order = c(1, 0, 1),
  xreg = data_std[, -1]
)
summary(arimax_std)

# Coefficient test
coeftest(arimax_std)
```

Last updated: 23 July 2025 Maintainer: \[Hongbo Zhao / Contact: hongbo.zhao\@uqconnect.edu.au\]
